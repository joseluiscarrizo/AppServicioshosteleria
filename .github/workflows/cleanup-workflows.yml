name: Cleanup Workflow Runs on PR Close

on:
  pull_request:
    types: [closed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to clean up (optional)'
        required: false
        default: ''

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      pull-requests: read
      contents: read
    steps:
      - name: Cancel and delete workflow runs for closed PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request?.number
              || (context.payload.inputs?.pr_number ? parseInt(context.payload.inputs.pr_number) : null);

            if (!prNumber) {
              console.log('No PR number found; skipping cleanup.');
              return;
            }

            console.log(`Cleaning up workflow runs for PR #${prNumber}...`);

            // Retrieve the head SHA(s) associated with this PR
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            const headSha = pr.head.sha;

            const { data: workflows } = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            let cancelled = 0;
            let deleted = 0;
            const persistentErrors = [];

            for (const workflow of workflows.workflows) {
              // List runs associated with this PR's head SHA
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflow.id,
                head_sha: headSha,
                per_page: 100
              });

              for (const run of runs.workflow_runs) {
                // Cancel in-progress or queued runs
                if (run.status === 'in_progress' || run.status === 'queued') {
                  try {
                    await github.rest.actions.cancelWorkflowRun({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      run_id: run.id
                    });
                    cancelled++;
                    console.log(`Cancelled run #${run.id} (${workflow.name})`);
                  } catch (e) {
                    console.warn(`Could not cancel run #${run.id}: ${e.message}`);
                  }
                }

                // Delete completed failed runs that are no longer relevant
                if (run.status === 'completed' && run.conclusion === 'failure') {
                  try {
                    await github.rest.actions.deleteWorkflowRun({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      run_id: run.id
                    });
                    deleted++;
                    console.log(`Deleted failed run #${run.id} (${workflow.name})`);
                  } catch (e) {
                    persistentErrors.push(`${workflow.name} run #${run.id}: ${e.message}`);
                    console.warn(`Could not delete run #${run.id}: ${e.message}`);
                  }
                }
              }
            }

            console.log(`\n=== Cleanup Summary for PR #${prNumber} ===`);
            console.log(`Cancelled runs:  ${cancelled}`);
            console.log(`Deleted runs:    ${deleted}`);
            if (persistentErrors.length > 0) {
              console.log(`Persistent errors (${persistentErrors.length}):`);
              persistentErrors.forEach(e => console.log(`  - ${e}`));
            }
            console.log('==========================================');
