name: Workflow Executor

on:
  workflow_dispatch:
    inputs:
      target_workflow:
        description: 'Name or filename of the workflow to trigger'
        required: true
        type: string
      target_ref:
        description: 'Branch, tag, or SHA to run the workflow on'
        required: false
        default: 'main'
        type: string
      correlation_id:
        description: 'Correlation ID from orchestrator (optional)'
        required: false
        type: string
      max_retries:
        description: 'Maximum retry attempts on failure (1-3)'
        required: false
        default: '3'
        type: string

permissions:
  actions: write
  contents: read

jobs:
  execute-workflow:
    name: Execute Target Workflow
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Resolve Correlation ID
        id: correlation
        run: |
          CID="${{ inputs.correlation_id }}"
          if [ -z "$CID" ]; then
            CID="executor-$(date +%Y%m%d%H%M%S)-${{ github.run_id }}"
          fi
          echo "id=${CID}" >> "$GITHUB_OUTPUT"
          echo "::notice title=Correlation ID::${CID}"

      - name: Log Execution Start
        run: |
          echo "::group::Workflow Executor — Execution Phase"
          echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "correlation_id=${{ steps.correlation.outputs.id }}"
          echo "target_workflow=${{ inputs.target_workflow }}"
          echo "target_ref=${{ inputs.target_ref }}"
          echo "max_retries=${{ inputs.max_retries }}"
          echo "::endgroup::"

      - name: Validate Inputs
        id: validate
        run: |
          TARGET="${{ inputs.target_workflow }}"
          REF="${{ inputs.target_ref }}"
          RETRIES="${{ inputs.max_retries }}"

          if [ -z "$TARGET" ]; then
            echo "::error title=Missing Input::target_workflow is required."
            exit 1
          fi

          if ! [[ "$RETRIES" =~ ^[1-3]$ ]]; then
            echo "::warning title=Invalid Retries::max_retries must be 1-3. Defaulting to 3."
            RETRIES=3
          fi

          echo "target=${TARGET}" >> "$GITHUB_OUTPUT"
          echo "ref=${REF}" >> "$GITHUB_OUTPUT"
          echo "retries=${RETRIES}" >> "$GITHUB_OUTPUT"
          echo "::notice title=Inputs Validated::target=${TARGET}, ref=${REF}, retries=${RETRIES}"

      - name: Trigger Target Workflow with Retry
        id: trigger
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TARGET="${{ steps.validate.outputs.target }}"
          REF="${{ steps.validate.outputs.ref }}"
          REPO="${{ github.repository }}"
          MAX_RETRIES="${{ steps.validate.outputs.retries }}"
          CORRELATION="${{ steps.correlation.outputs.id }}"

          attempt=1
          while [ "$attempt" -le "$MAX_RETRIES" ]; do
            echo "::group::Attempt ${attempt}/${MAX_RETRIES} — Triggering ${TARGET}"
            DELAY=$(( (attempt - 1) * (attempt - 1) * 5 ))
            if [ "$DELAY" -gt 0 ]; then
              echo "Exponential backoff: sleeping ${DELAY}s before retry…"
              sleep "$DELAY"
            fi

            HTTP_STATUS=$(gh api \
              --method POST \
              "repos/${REPO}/actions/workflows/${TARGET}/dispatches" \
              --field "ref=${REF}" \
              --field "inputs[correlation_id]=${CORRELATION}" \
              -i 2>&1 | head -1 | awk '{print $2}' || echo "0")

            if [ "$HTTP_STATUS" = "204" ] || [ "$HTTP_STATUS" = "200" ]; then
              echo "Workflow dispatched successfully on attempt ${attempt}."
              echo "triggered=true" >> "$GITHUB_OUTPUT"
              echo "attempts=${attempt}" >> "$GITHUB_OUTPUT"
              echo "::endgroup::"
              break
            else
              echo "::warning title=Trigger Failed::Attempt ${attempt} failed (HTTP ${HTTP_STATUS})."
              attempt=$(( attempt + 1 ))
              echo "::endgroup::"
            fi
          done

          if [ "$attempt" -gt "$MAX_RETRIES" ]; then
            echo "::error title=All Retries Exhausted::Failed to trigger ${TARGET} after ${MAX_RETRIES} attempts."
            echo "triggered=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

      - name: Monitor Triggered Workflow
        id: monitor
        if: steps.trigger.outputs.triggered == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REPO="${{ github.repository }}"
          TARGET="${{ steps.validate.outputs.target }}"
          TIMEOUT_MINUTES=90
          POLL_INTERVAL=30
          ELAPSED=0

          echo "::group::Monitoring ${TARGET} (timeout=${TIMEOUT_MINUTES}m, poll=${POLL_INTERVAL}s)"

          # Brief pause to allow GitHub to register the new run
          sleep 10

          while [ "$ELAPSED" -lt $(( TIMEOUT_MINUTES * 60 )) ]; do
            RUN_INFO=$(gh api \
              "repos/${REPO}/actions/workflows/${TARGET}/runs" \
              --jq '.workflow_runs[0] | {id: .id, status: .status, conclusion: .conclusion}' 2>/dev/null || echo '{}')

            STATUS=$(echo "$RUN_INFO" | jq -r '.status // "unknown"')
            CONCLUSION=$(echo "$RUN_INFO" | jq -r '.conclusion // "pending"')
            RUN_ID=$(echo "$RUN_INFO" | jq -r '.id // "unknown"')

            echo "$(date -u +%H:%M:%SZ) | run=${RUN_ID} status=${STATUS} conclusion=${CONCLUSION}"

            if [ "$STATUS" = "completed" ]; then
              echo "run_id=${RUN_ID}" >> "$GITHUB_OUTPUT"
              echo "conclusion=${CONCLUSION}" >> "$GITHUB_OUTPUT"
              echo "status=completed" >> "$GITHUB_OUTPUT"
              if [ "$CONCLUSION" = "success" ]; then
                echo "::notice title=Workflow Succeeded::${TARGET} completed successfully (run ${RUN_ID})."
              else
                echo "::error title=Workflow Failed::${TARGET} concluded with '${CONCLUSION}' (run ${RUN_ID})."
              fi
              break
            fi

            sleep "$POLL_INTERVAL"
            ELAPSED=$(( ELAPSED + POLL_INTERVAL ))
          done

          if [ "$ELAPSED" -ge $(( TIMEOUT_MINUTES * 60 )) ]; then
            echo "::error title=Timeout::Monitoring timed out after ${TIMEOUT_MINUTES} minutes."
            echo "status=timeout" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          echo "::endgroup::"

      - name: Emit Audit Event
        if: always()
        run: |
          echo "::group::Audit Trail Entry"
          cat <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "correlation_id": "${{ steps.correlation.outputs.id }}",
            "event": "workflow_executor",
            "target_workflow": "${{ inputs.target_workflow }}",
            "target_ref": "${{ inputs.target_ref }}",
            "triggered": "${{ steps.trigger.outputs.triggered }}",
            "attempts": "${{ steps.trigger.outputs.attempts }}",
            "monitored_run_id": "${{ steps.monitor.outputs.run_id }}",
            "final_status": "${{ steps.monitor.outputs.status }}",
            "final_conclusion": "${{ steps.monitor.outputs.conclusion }}",
            "automator": "workflow-executor",
            "result": "${{ job.status }}"
          }
          EOF
          echo "::endgroup::"
