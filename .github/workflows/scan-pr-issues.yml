name: Scan PR Issues & Status

on:
  schedule:
    - cron: '*/30 * * * *'  # Every 30 minutes
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  scan-issues:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
      checks: read
    steps:
      - uses: actions/checkout@v3

      - name: Scan all open PRs for issues
        id: scan
        uses: actions/github-script@v6
        with:
          script: |
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            const issues = {
              conflicts: [],
              failing_tests: [],
              stale: [],
              outdated: [],
              draft: [],
              needs_review: []
            };

            for (const pr of prs) {
              // 1. Check merge conflicts
              if (pr.mergeable === false) {
                issues.conflicts.push({
                  number: pr.number,
                  title: pr.title,
                  branch: pr.head.ref,
                  baseRef: pr.base.ref
                });
              }

              // 2. Check if stale (no updates in 7+ days)
              const updatedAt = new Date(pr.updated_at);
              const daysSinceUpdate = (Date.now() - updatedAt.getTime()) / (1000 * 60 * 60 * 24);

              if (daysSinceUpdate > 7) {
                issues.stale.push({
                  number: pr.number,
                  title: pr.title,
                  daysSinceUpdate: daysSinceUpdate.toFixed(1)
                });
              }

              // 3. Check if branch is outdated vs base
              try {
                const { data: comparison } = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: pr.head.ref,
                  head: pr.base.ref
                });

                if (comparison.behind_by > 5) {
                  issues.outdated.push({
                    number: pr.number,
                    title: pr.title,
                    commitsAhead: comparison.ahead_by,
                    commitsBehind: comparison.behind_by
                  });
                }
              } catch (e) {
                // Skip comparison if branches diverged too much
              }

              // 4. Check if PR is draft
              if (pr.draft) {
                issues.draft.push({
                  number: pr.number,
                  title: pr.title
                });
              }

              // 5. Check pending review requests
              const { data: requestedReviewers } = await github.rest.pulls.listRequestedReviewers({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const pendingCount = (requestedReviewers.users || []).length + (requestedReviewers.teams || []).length;
              if (pendingCount > 0) {
                issues.needs_review.push({
                  number: pr.number,
                  title: pr.title,
                  pendingCount
                });
              }

              // 6. Check test status
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });

              const failedChecks = checks.check_runs.filter(
                c => c.status === 'completed' && c.conclusion === 'failure'
              );

              if (failedChecks.length > 0) {
                issues.failing_tests.push({
                  number: pr.number,
                  title: pr.title,
                  failedChecks: failedChecks.map(c => c.name)
                });
              }
            }

            core.setOutput('issues', JSON.stringify(issues));
            return issues;

      - name: Tag and label problematic PRs
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issues = JSON.parse('${{ steps.scan.outputs.issues }}');

            // Label merge conflict PRs
            for (const pr of issues.conflicts) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['conflict', 'needs-repair', 'blocked']
              });
            }

            // Label stale PRs
            for (const pr of issues.stale) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['stale', 'needs-rebase']
              });
            }

            // Label outdated branches
            for (const pr of issues.outdated) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['outdated', 'needs-rebase']
              });
            }

            // Label failing tests
            for (const pr of issues.failing_tests) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['failing-tests', 'needs-repair']
              });
            }

            console.log(`âœ… Labeled ${Object.keys(issues).reduce((a, k) => a + issues[k].length, 0)} PRs`);
